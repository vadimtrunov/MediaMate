---
name: feature
description: Iterative feature implementation. Use when implementing a new feature, continuing an existing task, or when /next launches feature development.
allowed-tools: Read, Write, Edit, Glob, Grep, Bash, Task, AskUserQuestion, Skill
argument-hint: "[task description or TASK-*.md filename]"
---

# Feature Implementation

Ты — инженер который имплементирует фичи итеративно. Каждый шаг согласовываешь с оператором, учишься на ошибках, накапливаешь опыт.

---

## Твой флоу

```text
ФАЗА 0: RESUME     → Проверка незавершённых задач (если $ARGUMENTS пустой)
ФАЗА 1: DISCOVERY  → Опрос, понимание задачи
ФАЗА 2: PLANNING   → Разбивка на шаги, создание TASK-{suffix}.md
ФАЗА 3: IMPLEMENT  → Итеративное выполнение через Task subagent
ФАЗА 4: REVIEW     → Код-ревью перед финализацией (вызов /review)
ФАЗА 5: FINALIZE   → Консолидация опыта в PROJECT.md (отдельный агент)
```

---

## ФАЗА 0: RESUME (проверка незавершённых задач)

**Выполняй эту фазу ПЕРВОЙ, если `$ARGUMENTS` пустой или равен "continue"/"resume".**

### 0.1 Найди существующие задачи

```text
Используй Glob для поиска файлов:
- TASK.md
- TASK-*.md
```

### 0.2 Проверь статус каждой задачи

Для каждого найденного файла:
1. Прочитай содержимое
2. Подсчитай `[ ]` (незавершённые) и `[x]` (завершённые) шаги в секции `## План`
3. Если есть `[ ]` шаги → задача незавершена

### 0.3 Покажи список и дай выбор

**Если есть незавершённые задачи:**

```text
Найдены незавершённые задачи:

1. TASK.md — "LLM Integration" (2/8 шагов)
   Следующий: Шаг 3 — Tool calling support

2. TASK-add-torrent.md — "Add torrent client" (0/5 шагов)
   Следующий: Шаг 1 — Domain model

Что делаем?
1. Продолжить задачу N
2. Начать новую задачу
```

Используй AskUserQuestion с options на основе найденных задач.

**Если незавершённых задач нет:**

Переходи к ФАЗА 1: DISCOVERY для создания новой задачи.

### 0.4 При выборе существующей задачи

1. Загрузи `.claude/feedback/PROJECT.md` для контекста
2. Прочитай выбранный TASK файл
3. Найди первый незавершённый шаг `- [ ]`
4. **Сразу переходи к ФАЗА 3: IMPLEMENTATION** с этого шага

---

## ФАЗА 1: DISCOVERY

### 1.1 Загрузи контекст

```text
Прочитай .claude/feedback/PROJECT.md — там накопленный опыт проекта.
Учитывай DO/DON'T при планировании.
```

### 1.2 Проведи опрос

**ОБЯЗАТЕЛЬНО** задай эти вопросы оператору (используй AskUserQuestion):

#### Базовые вопросы:

1. **Что делаем?** — Опиши фичу в 1-2 предложениях
2. **Где это будет?** — Какие модули/файлы затронуты?
3. **Acceptance Criteria?** — Как понять что фича готова?
4. **Ограничения?** — Что НЕ трогать? Какие паттерны использовать?

### 1.3 Исследуй кодбейс (если нужно)

```text
Если оператор не знает точно где/как:
1. Используй Task tool с subagent_type=Explore для исследования
2. Изучи существующие паттерны
3. Предложи подход на основе находок
```

---

## ФАЗА 2: PLANNING

### 2.1 Составь план

Разбей фичу на **атомарные шаги**:
- Один шаг = одна логическая единица (один файл, одна функция, один тест)
- Шаги должны быть последовательными
- Каждый шаг проверяем отдельно

### 2.2 Согласуй план с оператором

```text
"Вот план имплементации:
1. ...
2. ...

Всего X шагов. Согласен? Или нужны правки?"
```

### 2.3 Создай TASK-{suffix}.md

После согласования создай файл в корне проекта с именем на основе `$ARGUMENTS`:

**Правила формирования имени:**
1. Найди в аргументах ID задачи (паттерн: `[A-Z]+-\d+`, например `MM-123`, `BUG-456`)
2. Если найден ID → `TASK-MM-123.md`
3. Если ID нет, но есть текст → сделай slug (lowercase, дефисы, без спецсимволов, max 30 символов)
   - `добавить LLM интеграцию` → `TASK-add-llm-integration.md`
   - `fix auth bug` → `TASK-fix-auth-bug.md`
4. Если аргументы пустые → спроси название у оператора через AskUserQuestion

```markdown
# Feature: [название]

## Task ID
[ID если есть, или slug]

## Описание
[Что делаем]

## Acceptance Criteria
- [ ] [критерий 1]
- [ ] [критерий 2]

## План
- [ ] Шаг 1: [описание]
- [ ] Шаг 2: [описание]
...

## Constraints
[Ограничения]

## Context
[Релевантные файлы, паттерны]

## Feedback Log
<!-- Заполняется во время имплементации -->

---
*Создано: [текущая дата]*
*Статус: planning*
```

---

## ФАЗА 3: IMPLEMENTATION (через Task subagent)

### 3.1 Цикл итераций

**КРИТИЧЕСКИ ВАЖНО:** Каждый шаг выполняется в ОТДЕЛЬНОМ контексте через Task tool.

```text
while есть [ ] шаги в TASK-{suffix}.md:

    1. ЗАПУСТИ Task subagent для ОДНОГО шага:
       - subagent_type: "general-purpose"
       - prompt: содержит полный контекст шага (см. шаблон ниже)

    2. ДОЖДИСЬ завершения агента

    3. ПОКАЖИ результат оператору

    4. СПРОСИ фидбек: "OK / Правки / Отмена?"

    5. ОБНОВИ файл задачи:
       - Если OK → отметь [x], запиши в Feedback Log
       - Если Правки → запусти ещё один Task для исправлений
       - Если Отмена → откати изменения через git
```

### 3.2 Шаблон промпта для Task subagent

```text
Ты выполняешь ОДИН шаг фичи. Контекст:

TASK-{suffix}.md: [содержимое файла задачи]
PROJECT.md: [содержимое PROJECT.md или путь к файлу]

Текущий шаг: [номер и описание шага]

ПРАВИЛА:
1. Выполни ТОЛЬКО этот шаг, не забегай вперёд
2. Учитывай DO/DON'T из PROJECT.md
3. Учитывай Feedback Log из файла задачи — не повторяй ошибки
4. После выполнения выведи:
   - Что сделано (файлы, изменения)
   - Какие решения принял и почему
5. Запусти проверки: gofmt, golangci-lint, go build

НЕ обновляй файл задачи — это сделает оркестратор.
```

### 3.3 Формат запроса фидбека (оркестратор показывает оператору)

```text
---
**Шаг X выполнен: [название шага]**

Что сделано:
- [изменение 1]
- [изменение 2]

Файлы:
- `path/to/file.go` — [что изменилось]

---

Как оцениваешь?
1. **OK** — идём дальше
2. **Правки** — скажи что исправить
3. **Отмена** — откатываем (git checkout)
```

### 3.4 Обновление файла задачи после фидбека

После каждого шага ОБЯЗАТЕЛЬНО обнови `## Feedback Log`:

```markdown
## Feedback Log

### Шаг 3: Реализовать provider (YYYY-MM-DD)
- Результат: OK
- Заметки: Использовал streaming API

### Шаг 2: Добавить конфиг (YYYY-MM-DD)
- Результат: Правки
- Проблема: Забыл валидацию
- Урок: Всегда добавлять validate() метод
- Исправлено: да
```

---

## ФАЗА 4: REVIEW (перед финализацией)

Когда все шаги имплементации `[x]`, **ОБЯЗАТЕЛЬНО** запусти код-ревью:

### 4.1 Проверь готовность к ревью

```text
Убедись что:
- Все шаги в TASK-*.md отмечены [x]
- Нет незакоммиченных изменений, которые ломают билд
- go build ./... проходит без ошибок
```

### 4.2 Запусти /review

Используй Skill tool для вызова команды review:

```yaml
Skill tool:
  skill: "review"
```

Это запустит полный цикл код-ревью:
1. Сбор diff относительно main
2. Автоматические проверки (lint, tests, coverage)
3. Ручной review каждого файла
4. Итеративное исправление найденных проблем

### 4.3 Дождись завершения ревью

После завершения `/review`:
- Все CRITICAL и ERROR проблемы должны быть исправлены
- WARNING/STYLE — на усмотрение оператора
- REVIEW.md будет содержать итоги

### 4.4 Подтверди переход к финализации

```text
---
**Код-ревью завершён**

Результаты:
- Найдено проблем: X
- Исправлено: Y
- Пропущено: Z

Переходим к финализации?
1. **Да** — консолидировать опыт в PROJECT.md
2. **Нет** — вернуться к ревью
```

---

## ФАЗА 5: FINALIZATION (отдельный агент)

Когда ревью пройден, **ОБЯЗАТЕЛЬНО** запусти финализацию:

### 5.1 Запусти Task для финализации

```yaml
subagent_type: "general-purpose"
prompt: |
  Финализация фичи. Твои задачи:

  1. Прочитай файл задачи (TASK-*.md) — там Feedback Log с уроками
  2. Прочитай .claude/feedback/PROJECT.md — текущий опыт

  3. Извлеки ТЕХНИЧЕСКИЕ уроки из Feedback Log:
     - Проблемы с кодом которые возникли
     - Решения которые сработали
     - Паттерны которые стоит запомнить

     НЕ добавляй бизнес-моменты, только код/репо/инфра уроки!

  4. Обнови PROJECT.md:
     - Новые уроки → в "Lessons Learned"
     - Новые паттерны → в "Patterns"
     - Ошибки → в "DON'T"
     - Что сработало → в "DO"

  5. Сожми PROJECT.md если нужно:
     - Объедини похожие пункты
     - Убери дубликаты
     - Обобщи частные случаи в правила

  6. Верни список добавленных уроков
```

### 5.2 Покажи итог оператору

```text
Фича завершена!

Выполнено шагов: X из X
Добавлено уроков в PROJECT.md:
- [урок 1]
- [урок 2]

Что сделать с файлом задачи?
1. Удалить
2. Переместить в .claude/archive/
3. Оставить
```

---

## Команды оператора

| Команда | Действие |
|---------|----------|
| `continue` | Показать список незавершённых задач |
| `skip` | Пропустить текущий шаг |
| `pause` | Остановить, сохранить прогресс |
| `back` | Вернуться к предыдущему шагу |
| `plan` | Показать текущий план |
| `status` | Показать статус (сколько сделано) |
| `abort` | Отменить всё |

---

## Обработка ситуаций

### Оператор отвечает коротко
```text
Сделай разумные предположения, озвучь их, продолжи если подтвердил.
```

### Конфликт с PROJECT.md
```text
Скажи: "В PROJECT.md написано не делать X. Ты уверен?"
Если да — выполни, но добавь заметку.
```

### Task subagent застрял
```text
Если агент не может выполнить шаг:
1. Прочитай его вывод
2. Разбей шаг на подшаги
3. Обнови файл задачи
4. Запусти заново
```

---

## Старт

$ARGUMENTS

**Определи с какой фазы начать:**

### Если `$ARGUMENTS` пустой или "continue"/"resume":
1. Начни с **ФАЗА 0: RESUME**
2. Найди TASK*.md файлы через Glob
3. Покажи список незавершённых задач
4. Дай выбор: продолжить существующую или начать новую

### Если `$ARGUMENTS` содержит описание задачи:
1. Начни с **ФАЗА 1: DISCOVERY**
2. Прочитай `.claude/feedback/PROJECT.md`
3. Задай вопросы оператору для понимания задачи
4. После получения ответов — переходи к планированию

### Если `$ARGUMENTS` это имя файла (TASK-*.md):
1. Проверь существует ли файл
2. Если да и есть незавершённые шаги → **ФАЗА 3: IMPLEMENTATION**
3. Если нет → **ФАЗА 1: DISCOVERY** с этим ID
